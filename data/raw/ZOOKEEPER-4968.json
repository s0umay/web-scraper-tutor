{"expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields", "id": "13626880", "self": "https://issues.apache.org/jira/rest/api/2/issue/13626880", "key": "ZOOKEEPER-4968", "fields": {"fixVersions": [{"self": "https://issues.apache.org/jira/rest/api/2/version/12313382", "id": "12313382", "description": "", "name": "4.0.0", "archived": false, "released": false}], "resolution": null, "customfield_12312322": null, "customfield_12312323": null, "customfield_12310420": "9223372036854775807", "customfield_12312320": null, "customfield_12312321": null, "customfield_12312328": null, "customfield_12312329": null, "customfield_12312326": null, "customfield_12310300": null, "customfield_12312327": null, "customfield_12312324": null, "customfield_12312720": null, "customfield_12312325": null, "lastViewed": null, "priority": {"self": "https://issues.apache.org/jira/rest/api/2/priority/3", "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg", "name": "Major", "id": "3"}, "labels": ["pull-request-available"], "customfield_12312333": null, "customfield_12312334": null, "customfield_12313422": "false", "customfield_12310310": "0.0", "customfield_12312331": null, "customfield_12312332": null, "aggregatetimeoriginalestimate": null, "timeestimate": 0, "customfield_12312330": null, "versions": [], "customfield_12311120": null, "customfield_12313826": null, "issuelinks": [{"id": "12707561", "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12707561", "type": {"id": "10030", "name": "Reference", "inward": "is related to", "outward": "relates to", "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"}, "outwardIssue": {"id": "13536841", "key": "ZOOKEEPER-4697", "self": "https://issues.apache.org/jira/rest/api/2/issue/13536841", "fields": {"summary": "Add Builder to construct ZooKeeper and possible descendants", "status": {"self": "https://issues.apache.org/jira/rest/api/2/status/5", "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.", "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png", "name": "Resolved", "id": "5", "statusCategory": {"self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3", "id": 3, "key": "done", "colorName": "green", "name": "Done"}}, "priority": {"self": "https://issues.apache.org/jira/rest/api/2/priority/3", "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg", "name": "Major", "id": "3"}, "issuetype": {"self": "https://issues.apache.org/jira/rest/api/2/issuetype/2", "id": "2", "description": "A new feature of the product, which has yet to be developed.", "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype", "name": "New Feature", "subtask": false, "avatarId": 21141}}}}, {"id": "12707586", "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12707586", "type": {"id": "12310051", "name": "Supercedes", "inward": "is superceded by", "outward": "supercedes", "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310051"}, "outwardIssue": {"id": "13626555", "key": "ZOOKEEPER-4963", "self": "https://issues.apache.org/jira/rest/api/2/issue/13626555", "fields": {"summary": "Introduce ZooKeeper::builder for ZooKeeperBuilder", "status": {"self": "https://issues.apache.org/jira/rest/api/2/status/5", "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.", "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png", "name": "Resolved", "id": "5", "statusCategory": {"self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3", "id": 3, "key": "done", "colorName": "green", "name": "Done"}}, "priority": {"self": "https://issues.apache.org/jira/rest/api/2/priority/4", "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/minor.svg", "name": "Minor", "id": "4"}, "issuetype": {"self": "https://issues.apache.org/jira/rest/api/2/issuetype/4", "id": "4", "description": "An improvement or enhancement to an existing feature or task.", "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype", "name": "Improvement", "subtask": false, "avatarId": 21140}}}}], "customfield_12312339": null, "customfield_12313825": null, "assignee": {"self": "https://issues.apache.org/jira/rest/api/2/user?username=kezhuw", "name": "kezhuw", "key": "kezhuw", "avatarUrls": {"48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=kezhuw&avatarId=37929", "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kezhuw&avatarId=37929", "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kezhuw&avatarId=37929", "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kezhuw&avatarId=37929"}, "displayName": "Kezhu Wang", "active": true, "timeZone": "Etc/GMT-8"}, "customfield_12312337": null, "customfield_12313823": null, "customfield_12312338": null, "customfield_12311920": null, "customfield_12313822": null, "customfield_12312335": null, "customfield_12313821": null, "customfield_12312336": null, "customfield_12313820": null, "status": {"self": "https://issues.apache.org/jira/rest/api/2/status/1", "description": "The issue is open and ready for the assignee to start work on it.", "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png", "name": "Open", "id": "1", "statusCategory": {"self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2", "id": 2, "key": "new", "colorName": "blue-gray", "name": "To Do"}}, "components": [{"self": "https://issues.apache.org/jira/rest/api/2/component/12312381", "id": "12312381", "name": "java client", "description": "The java client interface for ZooKeeper"}], "archiveddate": null, "customfield_12312026": null, "customfield_12312023": null, "customfield_12312024": null, "aggregatetimeestimate": 0, "customfield_12312022": null, "customfield_12310921": null, "customfield_12310920": "9223372036854775807", "customfield_12312823": null, "creator": {"self": "https://issues.apache.org/jira/rest/api/2/user?username=kezhuw", "name": "kezhuw", "key": "kezhuw", "avatarUrls": {"48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=kezhuw&avatarId=37929", "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kezhuw&avatarId=37929", "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kezhuw&avatarId=37929", "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kezhuw&avatarId=37929"}, "displayName": "Kezhu Wang", "active": true, "timeZone": "Etc/GMT-8"}, "subtasks": [], "reporter": {"self": "https://issues.apache.org/jira/rest/api/2/user?username=kezhuw", "name": "kezhuw", "key": "kezhuw", "avatarUrls": {"48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=kezhuw&avatarId=37929", "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kezhuw&avatarId=37929", "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kezhuw&avatarId=37929", "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kezhuw&avatarId=37929"}, "displayName": "Kezhu Wang", "active": true, "timeZone": "Etc/GMT-8"}, "aggregateprogress": {"progress": 2400, "total": 2400, "percent": 100}, "customfield_12313520": null, "customfield_12310250": null, "progress": {"progress": 2400, "total": 2400, "percent": 100}, "customfield_12313924": null, "votes": {"self": "https://issues.apache.org/jira/rest/api/2/issue/ZOOKEEPER-4968/votes", "votes": 1, "hasVoted": false}, "worklog": {"startAt": 0, "maxResults": 20, "total": 4, "worklogs": [{"self": "https://issues.apache.org/jira/rest/api/2/issue/13626880/worklog/979846", "author": {"self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot", "name": "githubbot", "key": "githubbot", "avatarUrls": {"48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452", "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452", "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452", "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"}, "displayName": "ASF GitHub Bot", "active": true, "timeZone": "Etc/UTC"}, "updateAuthor": {"self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot", "name": "githubbot", "key": "githubbot", "avatarUrls": {"48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452", "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452", "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452", "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"}, "displayName": "ASF GitHub Bot", "active": true, "timeZone": "Etc/UTC"}, "comment": "kezhuw opened a new pull request, #2308:\nURL: https://github.com/apache/zookeeper/pull/2308\n\n   Changes:\r\n   1. Add new interface `Zookeeper` in `o.a.z.client`.\r\n   2. Add `ZooKeeper::builder` to construct instance of `ZooKeeper`.\r\n   3. Add `ZooKeeperAdaptor` to proxy interface methods to `o.a.z.ZooKeeper` instance to keep abi compatibility.\n\n\n", "created": "2025-08-21T11:45:49.532+0000", "updated": "2025-08-21T11:45:49.532+0000", "started": "2025-08-21T11:45:49.531+0000", "timeSpent": "10m", "timeSpentSeconds": 600, "id": "979846", "issueId": "13626880"}, {"self": "https://issues.apache.org/jira/rest/api/2/issue/13626880/worklog/979905", "author": {"self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot", "name": "githubbot", "key": "githubbot", "avatarUrls": {"48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452", "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452", "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452", "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"}, "displayName": "ASF GitHub Bot", "active": true, "timeZone": "Etc/UTC"}, "updateAuthor": {"self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot", "name": "githubbot", "key": "githubbot", "avatarUrls": {"48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452", "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452", "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452", "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"}, "displayName": "ASF GitHub Bot", "active": true, "timeZone": "Etc/UTC"}, "comment": "anmolnar commented on code in PR #2308:\nURL: https://github.com/apache/zookeeper/pull/2308#discussion_r2291742649\n\n\n##########\nzookeeper-server/src/test/java/org/apache/zookeeper/client/ZooKeeperBuilderTest.java:\n##########\n@@ -79,7 +78,7 @@ public void testBuildClient() throws Exception {\n     @Test\n     public void testBuildAdminClient() throws Exception {\n         BlockingQueue<WatchedEvent> events = new LinkedBlockingQueue<>();\n-        ZooKeeper zk = new ZooKeeperBuilder(hostPort, Duration.ofMillis(1000))\n+        ZooKeeper zk = ZooKeeper.builder(hostPort, Duration.ofMillis(1000))\n\nReview Comment:\n   Return interface should be `ZooKeeperAdmin`.\n\n\n\n##########\nzookeeper-server/src/main/java/org/apache/zookeeper/client/ZooKeeperAdaptor.java:\n##########\n@@ -0,0 +1,361 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.zookeeper.client;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import org.apache.zookeeper.AddWatchMode;\n+import org.apache.zookeeper.AsyncCallback;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.Op;\n+import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.Transaction;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.data.ACL;\n+import org.apache.zookeeper.data.ClientInfo;\n+import org.apache.zookeeper.data.Stat;\n+\n+class ZooKeeperAdaptor implements ZooKeeper {\n\nReview Comment:\n   Some javadoc?\n\n\n\n", "created": "2025-08-21T17:41:22.309+0000", "updated": "2025-08-21T17:41:22.309+0000", "started": "2025-08-21T17:41:22.308+0000", "timeSpent": "10m", "timeSpentSeconds": 600, "id": "979905", "issueId": "13626880"}, {"self": "https://issues.apache.org/jira/rest/api/2/issue/13626880/worklog/980149", "author": {"self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot", "name": "githubbot", "key": "githubbot", "avatarUrls": {"48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452", "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452", "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452", "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"}, "displayName": "ASF GitHub Bot", "active": true, "timeZone": "Etc/UTC"}, "updateAuthor": {"self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot", "name": "githubbot", "key": "githubbot", "avatarUrls": {"48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452", "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452", "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452", "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"}, "displayName": "ASF GitHub Bot", "active": true, "timeZone": "Etc/UTC"}, "comment": "kezhuw commented on code in PR #2308:\nURL: https://github.com/apache/zookeeper/pull/2308#discussion_r2295356440\n\n\n##########\nzookeeper-server/src/main/java/org/apache/zookeeper/client/ZooKeeperAdaptor.java:\n##########\n@@ -0,0 +1,365 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.zookeeper.client;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import org.apache.zookeeper.AddWatchMode;\n+import org.apache.zookeeper.AsyncCallback;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.Op;\n+import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.Transaction;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.data.ACL;\n+import org.apache.zookeeper.data.ClientInfo;\n+import org.apache.zookeeper.data.Stat;\n+\n+/**\n+ * Adaptor to bridge {@link org.apache.zookeeper.ZooKeeper} to implement {@link ZooKeeper} while not introducing\n+ * abi compatibility issue.\n\nReview Comment:\n   It is a breaking change in abi level to implement `ZooKeeper` for `org.apache.zookeeper.ZooKeeper`.\r\n   \r\n   Adaptor is also good if we want to modify behavior slightly.\n\n\n\n##########\nzookeeper-server/src/main/java/org/apache/zookeeper/client/ZooKeeper.java:\n##########\n@@ -0,0 +1,1122 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.zookeeper.client;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.util.List;\n+import org.apache.zookeeper.AddWatchMode;\n+import org.apache.zookeeper.AsyncCallback;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.Op;\n+import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.Transaction;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.data.ACL;\n+import org.apache.zookeeper.data.ClientInfo;\n+import org.apache.zookeeper.data.Stat;\n+import org.apache.zookeeper.server.EphemeralType;\n+\n+/**\n+ * This is the main class of ZooKeeper client library. To use a ZooKeeper\n+ * service, an application must first instantiate an object of ZooKeeper class.\n+ * All the iterations will be done by calling the methods of ZooKeeper class.\n+ * The methods of this class are thread-safe unless otherwise noted.\n+ * <p>\n+ * Once a connection to a server is established, a session ID is assigned to the\n+ * client. The client will send heart beats to the server periodically to keep\n+ * the session valid.\n+ * <p>\n+ * The application can call ZooKeeper APIs through a client as long as the\n+ * session ID of the client remains valid.\n+ * <p>\n+ * If for some reason, the client fails to send heart beats to the server for a\n+ * prolonged period of time (exceeding the sessionTimeout value, for instance),\n+ * the server will expire the session, and the session ID will become invalid.\n+ * The client object will no longer be usable. To make ZooKeeper API calls, the\n+ * application must create a new client object.\n+ * <p>\n+ * If the ZooKeeper server the client currently connects to fails or otherwise\n+ * does not respond, the client will automatically try to connect to another\n+ * server before its session ID expires. If successful, the application can\n+ * continue to use the client.\n+ * <p>\n+ * The ZooKeeper API methods are either synchronous or asynchronous. Synchronous\n+ * methods blocks until the server has responded. Asynchronous methods just queue\n+ * the request for sending and return immediately. They take a callback object that\n+ * will be executed either on successful execution of the request or on error with\n+ * an appropriate return code (rc) indicating the error.\n+ * <p>\n+ * Some successful ZooKeeper API calls can leave watches on the \"data nodes\" in\n+ * the ZooKeeper server. Other successful ZooKeeper API calls can trigger those\n+ * watches. Once a watch is triggered, an event will be delivered to the client\n+ * which left the watch at the first place. Each watch can be triggered only\n+ * once. Thus, up to one event will be delivered to a client for every watch it\n+ * leaves.\n+ * <p>\n+ * A client needs an object of a class implementing Watcher interface for\n+ * processing the events delivered to the client.\n+ *\n+ * When a client drops the current connection and re-connects to a server, all the\n+ * existing watches are considered as being triggered but the undelivered events\n+ * are lost. To emulate this, the client will generate a special event to tell\n+ * the event handler a connection has been dropped. This special event has\n+ * EventType None and KeeperState Disconnected.\n+ */\n+public interface ZooKeeper extends AutoCloseable {\n+    /**\n+     * Creates a builder with given connect string and session timeout.\n+     *\n+     * @param connectString\n+     *            comma separated host:port pairs, each corresponding to a zk\n+     *            server. e.g. \"127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002\"\n+     *            If the optional chroot suffix is used the example would look\n+     *            like: \"127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002/app/a\"\n+     *            where the client would be rooted at \"/app/a\" and all paths\n+     *            would be relative to this root - ie getting/setting/etc...\n+     *            \"/foo/bar\" would result in operations being run on\n+     *            \"/app/a/foo/bar\" (from the server perspective).\n+     * @param sessionTimeout\n+     *            session timeout\n+     */\n+    static ZooKeeperBuilder builder(String connectString, Duration sessionTimeout) {\n+        return new ZooKeeperBuilder(connectString, sessionTimeout);\n+    }\n+\n+    /**\n+     * The session id for this ZooKeeper client instance. The value returned is\n+     * not valid until the client connects to a server and may change after a\n+     * re-connect.\n+     *\n+     * <p>This method is NOT thread safe\n+     *\n+     * @return current session id\n+     */\n+    long getSessionId();\n+\n+    /**\n+     * The session password for this ZooKeeper client instance. The value\n+     * returned is not valid until the client connects to a server and may\n+     * change after a re-connect.\n+     *\n+     * <p>This method is NOT thread safe\n+     *\n+     * @return current session password\n+     */\n+    byte[] getSessionPasswd();\n+\n+    /**\n+     * The negotiated session timeout for this ZooKeeper client instance. The\n+     * value returned is not valid until the client connects to a server and\n+     * may change after a re-connect.\n+     *\n+     * This method is NOT thread safe\n+     *\n+     * @return current session timeout\n+     */\n+    int getSessionTimeout();\n+\n+    /**\n+     * Client config.\n+     */\n+    ZKClientConfig getClientConfig();\n+\n+    /**\n+     * Add the specified scheme:auth information to this connection.\n+     *\n+     * @param scheme auth scheme\n+     * @param auth auth data\n+     */\n+    void addAuthInfo(String scheme, byte[] auth);\n+\n+    /**\n+     * Specify the default watcher for the connection (overrides the one\n+     * specified during construction).\n+     */\n+    void register(Watcher watcher);\n+\n+    /**\n+     * This function allows a client to update the connection string by providing\n+     * a new comma separated list of host:port pairs, each corresponding to a\n+     * ZooKeeper server.\n+     * <p>\n+     * The function invokes a <a href=\"https://issues.apache.org/jira/browse/ZOOKEEPER-1355\">\n+     * probabilistic load-balancing algorithm</a> which may cause the client to disconnect from\n+     * its current host with the goal to achieve expected uniform number of connections per server\n+     * in the new list. In case the current host to which the client is connected is not in the new\n+     * list this call will always cause the connection to be dropped. Otherwise, the decision\n+     * is based on whether the number of servers has increased or decreased and by how much.\n+     * For example, if the previous connection string contained 3 hosts and now the list contains\n+     * these 3 hosts and 2 more hosts, 40% of clients connected to each of the 3 hosts will\n+     * move to one of the new hosts in order to balance the load. The algorithm will disconnect\n+     * from the current host with probability 0.4 and in this case cause the client to connect\n+     * to one of the 2 new hosts, chosen at random.\n+     * <p>\n+     * If the connection is dropped, the client moves to a special mode \"reconfigMode\" where he chooses\n+     * a new server to connect to using the probabilistic algorithm. After finding a server,\n+     * or exhausting all servers in the new list after trying all of them and failing to connect,\n+     * the client moves back to the normal mode of operation where it will pick an arbitrary server\n+     * from the connectString and attempt to connect to it. If establishment of\n+     * the connection fails, another server in the connect string will be tried\n+     * (the order is non-deterministic, as we random shuffle the list), until a\n+     * connection is established. The client will continue attempts until the\n+     * session is explicitly closed (or the session is expired by the server).\n+     * @param connectString\n+     *            comma separated host:port pairs, each corresponding to a zk\n+     *            server. e.g. \"127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002\"\n+     *            If the optional chroot suffix is used the example would look\n+     *            like: \"127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002/app/a\"\n+     *            where the client would be rooted at \"/app/a\" and all paths\n+     *            would be relative to this root - ie getting/setting/etc...\n+     *            \"/foo/bar\" would result in operations being run on\n+     *            \"/app/a/foo/bar\" (from the server perspective).\n+     *\n+     * @throws IOException in cases of network failure\n+     */\n+    void updateServerList(String connectString) throws IOException;\n+\n+    /**\n+     * Close this client object. Once the client is closed, its session becomes\n+     * invalid. All the ephemeral nodes in the ZooKeeper server associated with\n+     * the session will be removed. The watches left on those nodes (and on\n+     * their parents) will be triggered.\n+     * <p>\n+     * Added in 3.5.3: <a href=\"https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html\">try-with-resources</a>\n+     * may be used instead of calling close directly.\n+     * </p>\n+     * <p>\n+     * This method does not wait for all internal threads to exit.\n+     * Use the {@link #close(int) } method to wait for all resources to be released\n+     * </p>\n+     *\n+     * @throws InterruptedException\n+     */\n+    void close() throws InterruptedException;\n+\n+    /**\n+     * Close this client object as the {@link #close() } method.\n+     * This method will wait for internal resources to be released.\n+     *\n+     * @param waitForShutdownTimeoutMs timeout (in milliseconds) to wait for resources to be released.\n+     * Use zero or a negative value to skip the wait\n+     * @throws InterruptedException\n+     * @return true if waitForShutdownTimeout is greater than zero and all of the resources have been released\n+     *\n+     * @since 3.5.4\n+     */\n+    boolean close(int waitForShutdownTimeoutMs) throws InterruptedException;\n+\n+    /**\n+     * Create a node with the given path. The node data will be the given data,\n+     * and node acl will be the given acl.\n+     * <p>\n+     * The flags argument specifies whether the created node will be ephemeral\n+     * or not.\n+     * <p>\n+     * An ephemeral node will be removed by the ZooKeeper automatically when the\n+     * session associated with the creation of the node expires.\n+     * <p>\n+     * The flags argument can also specify to create a sequential node. The\n+     * actual path name of a sequential node will be the given path plus a\n+     * suffix \"i\" where i is the current sequential number of the node. The sequence\n+     * number is always fixed length of 10 digits, 0 padded. Once\n+     * such a node is created, the sequential number will be incremented by one.\n+     * <p>\n+     * If a node with the same actual path already exists in the ZooKeeper, a\n+     * KeeperException with error code KeeperException.NodeExists will be\n+     * thrown. Note that since a different actual path is used for each\n+     * invocation of creating sequential node with the same path argument, the\n+     * call will never throw \"file exists\" KeeperException.\n+     * <p>\n+     * If the parent node does not exist in the ZooKeeper, a KeeperException\n+     * with error code KeeperException.NoNode will be thrown.\n+     * <p>\n+     * An ephemeral node cannot have children. If the parent node of the given\n+     * path is ephemeral, a KeeperException with error code\n+     * KeeperException.NoChildrenForEphemerals will be thrown.\n+     * <p>\n+     * This operation, if successful, will trigger all the watches left on the\n+     * node of the given path by exists and getData API calls, and the watches\n+     * left on the parent node by getChildren API calls.\n+     * <p>\n+     * If a node is created successfully, the ZooKeeper server will trigger the\n+     * watches on the path left by exists calls, and the watches on the parent\n+     * of the node by getChildren calls.\n+     * <p>\n+     * The maximum allowable size of the data array is 1 MB (1,048,576 bytes).\n+     * Arrays larger than this will cause a KeeperException to be thrown.\n+     *\n+     * @param path\n+     *                the path for the node\n+     * @param data\n+     *                the initial data for the node\n+     * @param acl\n+     *                the acl for the node\n+     * @param createMode\n+     *                specifying whether the node to be created is ephemeral\n+     *                and/or sequential\n+     * @return the actual path of the created node\n+     * @throws KeeperException if the server returns a non-zero error code\n+     * @throws KeeperException.InvalidACLException if the ACL is invalid, null, or empty\n+     * @throws InterruptedException if the transaction is interrupted\n+     * @throws IllegalArgumentException if an invalid path is specified\n+     */\n+    String create(\n+            String path,\n+            byte[] data,\n+            List<ACL> acl,\n+            CreateMode createMode) throws KeeperException, InterruptedException;\n+\n+    /**\n+     * Create a node with the given path and returns the Stat of that node. The\n+     * node data will be the given data and node acl will be the given acl.\n+     * <p>\n+     * The flags argument specifies whether the created node will be ephemeral\n+     * or not.\n+     * <p>\n+     * An ephemeral node will be removed by the ZooKeeper automatically when the\n+     * session associated with the creation of the node expires.\n+     * <p>\n+     * The flags argument can also specify to create a sequential node. The\n+     * actual path name of a sequential node will be the given path plus a\n+     * suffix \"i\" where i is the current sequential number of the node. The sequence\n+     * number is always fixed length of 10 digits, 0 padded. Once\n+     * such a node is created, the sequential number will be incremented by one.\n+     * <p>\n+     * If a node with the same actual path already exists in the ZooKeeper, a\n+     * KeeperException with error code KeeperException.NodeExists will be\n+     * thrown. Note that since a different actual path is used for each\n+     * invocation of creating sequential node with the same path argument, the\n+     * call will never throw \"file exists\" KeeperException.\n+     * <p>\n+     * If the parent node does not exist in the ZooKeeper, a KeeperException\n+     * with error code KeeperException.NoNode will be thrown.\n+     * <p>\n+     * An ephemeral node cannot have children. If the parent node of the given\n+     * path is ephemeral, a KeeperException with error code\n+     * KeeperException.NoChildrenForEphemerals will be thrown.\n+     * <p>\n+     * This operation, if successful, will trigger all the watches left on the\n+     * node of the given path by exists and getData API calls, and the watches\n+     * left on the parent node by getChildren API calls.\n+     * <p>\n+     * If a node is created successfully, the ZooKeeper server will trigger the\n+     * watches on the path left by exists calls, and the watches on the parent\n+     * of the node by getChildren calls.\n+     * <p>\n+     * The maximum allowable size of the data array is 1 MB (1,048,576 bytes).\n+     * Arrays larger than this will cause a KeeperException to be thrown.\n+     *\n+     * @param path\n+     *                the path for the node\n+     * @param data\n+     *                the initial data for the node\n+     * @param acl\n+     *                the acl for the node\n+     * @param createMode\n+     *                specifying whether the node to be created is ephemeral\n+     *                and/or sequential\n+     * @param stat\n+     *                The output Stat object.\n+     * @return the actual path of the created node\n+     * @throws KeeperException if the server returns a non-zero error code\n+     * @throws KeeperException.InvalidACLException if the ACL is invalid, null, or empty\n+     * @throws InterruptedException if the transaction is interrupted\n+     * @throws IllegalArgumentException if an invalid path is specified\n+     */\n+    String create(\n+            String path,\n+            byte[] data,\n+            List<ACL> acl,\n+            CreateMode createMode,\n+            Stat stat) throws KeeperException, InterruptedException;\n+\n+    /**\n+     * same as {@link #create(String, byte[], List, CreateMode, Stat)} but\n+     * allows for specifying a TTL when mode is {@link CreateMode#PERSISTENT_WITH_TTL}\n+     * or {@link CreateMode#PERSISTENT_SEQUENTIAL_WITH_TTL}. If the znode has not been modified\n+     * within the given TTL, it will be deleted once it has no children. The TTL unit is\n+     * milliseconds and must be greater than 0 and less than or equal to\n+     * {@link EphemeralType#maxValue()} for {@link EphemeralType#TTL}.\n+     */\n+    String create(\n+            String path,\n+            byte[] data,\n+            List<ACL> acl,\n+            CreateMode createMode,\n+            Stat stat,\n+            long ttl) throws KeeperException, InterruptedException;\n+\n+    /**\n+     * The asynchronous version of create.\n+     *\n+     * @see #create(String, byte[], List, CreateMode)\n+     */\n+    void create(\n+            String path,\n+            byte[] data,\n+            List<ACL> acl,\n+            CreateMode createMode,\n+            AsyncCallback.StringCallback cb,\n+            Object ctx);\n+\n+    /**\n+     * The asynchronous version of create.\n+     *\n+     * @see #create(String, byte[], List, CreateMode, Stat)\n+     */\n+    void create(\n+            String path,\n+            byte[] data,\n+            List<ACL> acl,\n+            CreateMode createMode,\n+            AsyncCallback.Create2Callback cb,\n+            Object ctx);\n+\n+    /**\n+     * The asynchronous version of create with ttl.\n+     *\n+     * @see #create(String, byte[], List, CreateMode, Stat, long)\n+     */\n+    void create(\n+            String path,\n+            byte[] data,\n+            List<ACL> acl,\n+            CreateMode createMode,\n+            AsyncCallback.Create2Callback cb,\n+            Object ctx,\n+            long ttl);\n+\n+    /**\n+     * Return the stat of the node of the given path. Return null if no such a\n+     * node exists.\n+     * <p>\n+     * If the watch is non-null and the call is successful (no exception is thrown),\n+     * a watch will be left on the node with the given path. The watch will be\n+     * triggered by a successful operation that creates/delete the node or sets\n+     * the data on the node.\n+     *\n+     * @param path the node path\n+     * @param watcher explicit watcher\n+     * @return the stat of the node of the given path; return null if no such a\n+     *         node exists.\n+     * @throws KeeperException If the server signals an error\n+     * @throws InterruptedException If the server transaction is interrupted.\n+     * @throws IllegalArgumentException if an invalid path is specified\n+     */\n+    Stat exists(String path, Watcher watcher) throws KeeperException, InterruptedException;\n+\n+    /**\n+     * Return the stat of the node of the given path. Return null if no such a\n+     * node exists.\n+     *\n+     * <p>If the watch is true and the call is successful (no exception is thrown),\n+     * a watch will be left on the node with the given path. The watch will be\n+     * triggered by a successful operation that creates/delete the node or sets\n+     * the data on the node.\n+     *\n+     * @param path the node path\n+     * @param watch whether need to watch this node\n+     * @return the stat of the node of the given path; return null if no such a\n+     *         node exists.\n+     * @throws KeeperException If the server signals an error\n+     * @throws IllegalStateException if watch this node with a null default watcher\n+     * @throws InterruptedException If the server transaction is interrupted.\n+     */\n+    Stat exists(String path, boolean watch) throws KeeperException, InterruptedException;\n+\n+    /**\n+     * The asynchronous version of exists.\n+     *\n+     * @see #exists(String, Watcher)\n+     */\n+    void exists(String path, Watcher watcher, AsyncCallback.StatCallback cb, Object ctx);\n+\n+    /**\n+     * The asynchronous version of exists.\n+     *\n+     * @throws IllegalStateException if watch this node with a null default watcher\n+     *\n+     * @see #exists(String, boolean)\n+     */\n+    void exists(String path, boolean watch, AsyncCallback.StatCallback cb, Object ctx);\n+\n+    /**\n+     * Delete the node with the given path. The call will succeed if such a node\n+     * exists, and the given version matches the node's version (if the given\n+     * version is -1, it matches any node's versions).\n+     * <p>\n+     * A KeeperException with error code KeeperException.NoNode will be thrown\n+     * if the nodes does not exist.\n+     * <p>\n+     * A KeeperException with error code KeeperException.BadVersion will be\n+     * thrown if the given version does not match the node's version.\n+     * <p>\n+     * A KeeperException with error code KeeperException.NotEmpty will be thrown\n+     * if the node has children.\n+     * <p>\n+     * This operation, if successful, will trigger all the watches on the node\n+     * of the given path left by exists API calls, and the watches on the parent\n+     * node left by getChildren API calls.\n+     *\n+     * @param path\n+     *                the path of the node to be deleted.\n+     * @param version\n+     *                the expected node version.\n+     * @throws InterruptedException IF the server transaction is interrupted\n+     * @throws KeeperException If the server signals an error with a non-zero\n+     *   return code.\n+     * @throws IllegalArgumentException if an invalid path is specified\n+     */\n+    void delete(String path, int version) throws InterruptedException, KeeperException;\n+\n+    /**\n+     * The asynchronous version of delete.\n+     *\n+     * @see #delete(String, int)\n+     */\n+    void delete(String path, int version, AsyncCallback.VoidCallback cb, Object ctx);\n+\n+    /**\n+     * Executes multiple ZooKeeper operations. In case of transactions all of them or none of them will be executed.\n+     * <p>\n+     * On success, a list of results is returned.\n+     * On failure, an exception is raised which contains partial results and\n+     * error details, see {@link KeeperException#getResults}\n+     * <p>\n+     * Note: The maximum allowable size of all of the data arrays in all of\n+     * the setData operations in this single request is typically 1 MB\n+     * (1,048,576 bytes). This limit is specified on the server via\n+     * <a href=\"http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#Unsafe+Options\">jute.maxbuffer</a>.\n+     * Requests larger than this will cause a KeeperException to be\n+     * thrown.\n+     *\n+     * @param ops An iterable that contains the operations to be done.\n+     * These should be created using the factory methods on {@link Op} and must be the same kind of ops.\n+     * @return A list of results, one for each input Op, the order of\n+     * which exactly matches the order of the <code>ops</code> input\n+     * operations.\n+     * @throws InterruptedException If the operation was interrupted.\n+     * The operation may or may not have succeeded, but will not have\n+     * partially succeeded if this exception is thrown.\n+     * @throws KeeperException If the operation could not be completed\n+     * due to some error in doing one of the specified ops.\n+     * @throws IllegalArgumentException if an invalid path is specified or different kind of ops are mixed\n+     *\n+     * @since 3.4.0\n+     */\n+    List<OpResult> multi(Iterable<Op> ops) throws InterruptedException, KeeperException;\n+\n+    /**\n+     * The asynchronous version of multi.\n+     *\n+     * @see #multi(Iterable)\n+     */\n+    void multi(Iterable<Op> ops, AsyncCallback.MultiCallback cb, Object ctx);\n+\n+    /**\n+     * Return the data and the stat of the node of the given path.\n+     * <p>\n+     * If the watch is non-null and the call is successful (no exception is\n+     * thrown), a watch will be left on the node with the given path. The watch\n+     * will be triggered by a successful operation that sets data on the node, or\n+     * deletes the node.\n+     * <p>\n+     * A KeeperException with error code KeeperException.NoNode will be thrown\n+     * if no node with the given path exists.\n+     *\n+     * @param path the given path\n+     * @param watcher explicit watcher\n+     * @param stat the stat of the node\n+     * @return the data of the node\n+     * @throws KeeperException If the server signals an error with a non-zero error code\n+     * @throws InterruptedException If the server transaction is interrupted.\n+     * @throws IllegalArgumentException if an invalid path is specified\n+     */\n+    byte[] getData(String path, Watcher watcher, Stat stat) throws KeeperException, InterruptedException;\n+\n+    /**\n+     * Return the data and the stat of the node of the given path.\n+     * <p>\n+     * If the watch is true and the call is successful (no exception is\n+     * thrown), a watch will be left on the node with the given path. The watch\n+     * will be triggered by a successful operation that sets data on the node, or\n+     * deletes the node.\n+     * <p>\n+     * A KeeperException with error code KeeperException.NoNode will be thrown\n+     * if no node with the given path exists.\n+     *\n+     * @param path the given path\n+     * @param watch whether need to watch this node\n+     * @param stat the stat of the node\n+     * @return the data of the node\n+     * @throws KeeperException If the server signals an error with a non-zero error code\n+     * @throws IllegalStateException if watch this node with a null default watcher\n+     * @throws InterruptedException If the server transaction is interrupted.\n+     */\n+    byte[] getData(String path, boolean watch, Stat stat) throws KeeperException, InterruptedException;\n+\n+    /**\n+     * The asynchronous version of getData.\n+     *\n+     * @see #getData(String, Watcher, Stat)\n+     */\n+    void getData(String path, Watcher watcher, AsyncCallback.DataCallback cb, Object ctx);\n+\n+    /**\n+     * The asynchronous version of getData.\n+     *\n+     * @throws IllegalStateException if watch this node with a null default watcher\n+     *\n+     * @see #getData(String, boolean, Stat)\n+     */\n+    void getData(String path, boolean watch, AsyncCallback.DataCallback cb, Object ctx);\n+\n+    /**\n+     * Return the last committed configuration (as known to the server to which the client is connected)\n+     * and the stat of the configuration.\n+     * <p>\n+     * If the watch is non-null and the call is successful (no exception is\n+     * thrown), a watch will be left on the configuration node (ZooDefs.CONFIG_NODE). The watch\n+     * will be triggered by a successful reconfig operation\n+     * <p>\n+     * A KeeperException with error code KeeperException.NoNode will be thrown\n+     * if the configuration node doesn't exists.\n+     *\n+     * @param watcher explicit watcher\n+     * @param stat the stat of the configuration node ZooDefs.CONFIG_NODE\n+     * @return configuration data stored in ZooDefs.CONFIG_NODE\n+     * @throws KeeperException If the server signals an error with a non-zero error code\n+     * @throws InterruptedException If the server transaction is interrupted.\n+     */\n+    byte[] getConfig(Watcher watcher, Stat stat) throws KeeperException, InterruptedException;\n+\n+    /**\n+     * The asynchronous version of getConfig.\n+     *\n+     * @see #getConfig(Watcher, Stat)\n+     */\n+    void getConfig(Watcher watcher, AsyncCallback.DataCallback cb, Object ctx);\n+\n+    /**\n+     * Return the last committed configuration (as known to the server to which the client is connected)\n+     * and the stat of the configuration.\n+     * <p>\n+     * If the watch is true and the call is successful (no exception is\n+     * thrown), a watch will be left on the configuration node (ZooDefs.CONFIG_NODE). The watch\n+     * will be triggered by a successful reconfig operation\n+     * <p>\n+     * A KeeperException with error code KeeperException.NoNode will be thrown\n+     * if no node with the given path exists.\n+     *\n+     * @param watch whether need to watch this node\n+     * @param stat the stat of the configuration node ZooDefs.CONFIG_NODE\n+     * @return configuration data stored in ZooDefs.CONFIG_NODE\n+     * @throws KeeperException If the server signals an error with a non-zero error code\n+     * @throws IllegalStateException if watch this node with a null default watcher\n+     * @throws InterruptedException If the server transaction is interrupted.\n+     */\n+    byte[] getConfig(boolean watch, Stat stat) throws KeeperException, InterruptedException;\n+\n+    /**\n+     * The Asynchronous version of getConfig.\n+     *\n+     * @throws IllegalStateException if watch this node with a null default watcher\n+     *\n+     * @see #getData(String, boolean, Stat)\n+     */\n+    void getConfig(boolean watch, AsyncCallback.DataCallback cb, Object ctx);\n+\n+    /**\n+     * Set the data for the node of the given path if such a node exists and the\n+     * given version matches the version of the node (if the given version is\n+     * -1, it matches any node's versions). Return the stat of the node.\n+     * <p>\n+     * This operation, if successful, will trigger all the watches on the node\n+     * of the given path left by getData calls.\n+     * <p>\n+     * A KeeperException with error code KeeperException.NoNode will be thrown\n+     * if no node with the given path exists.\n+     * <p>\n+     * A KeeperException with error code KeeperException.BadVersion will be\n+     * thrown if the given version does not match the node's version.\n+     * <p>\n+     * The maximum allowable size of the data array is 1 MB (1,048,576 bytes).\n+     * Arrays larger than this will cause a KeeperException to be thrown.\n+     *\n+     * @param path\n+     *                the path of the node\n+     * @param data\n+     *                the data to set\n+     * @param version\n+     *                the expected matching version\n+     * @return the state of the node\n+     * @throws InterruptedException If the server transaction is interrupted.\n+     * @throws KeeperException If the server signals an error with a non-zero error code.\n+     * @throws IllegalArgumentException if an invalid path is specified\n+     */\n+    Stat setData(String path, byte[] data, int version) throws KeeperException, InterruptedException;\n+\n+    /**\n+     * The asynchronous version of setData.\n+     *\n+     * @see #setData(String, byte[], int)\n+     */\n+    void setData(String path, byte[] data, int version, AsyncCallback.StatCallback cb, Object ctx);\n+\n+    /**\n+     * Return the ACL and stat of the node of the given path.\n+     * <p>\n+     * A KeeperException with error code KeeperException.NoNode will be thrown\n+     * if no node with the given path exists.\n+     *\n+     * @param path\n+     *                the given path for the node\n+     * @param stat\n+     *                the stat of the node will be copied to this parameter if\n+     *                not null.\n+     * @return the ACL array of the given node.\n+     * @throws InterruptedException If the server transaction is interrupted.\n+     * @throws KeeperException If the server signals an error with a non-zero error code.\n+     * @throws IllegalArgumentException if an invalid path is specified\n+     */\n+    List<ACL> getACL(String path, Stat stat) throws KeeperException, InterruptedException;\n+\n+    /**\n+     * The asynchronous version of getACL.\n+     *\n+     * @see #getACL(String, Stat)\n+     */\n+    void getACL(String path, Stat stat, AsyncCallback.ACLCallback cb, Object ctx);\n+\n+    /**\n+     * Set the ACL for the node of the given path if such a node exists and the\n+     * given aclVersion matches the acl version of the node. Return the stat of the\n+     * node.\n+     * <p>\n+     * A KeeperException with error code KeeperException.NoNode will be thrown\n+     * if no node with the given path exists.\n+     * <p>\n+     * A KeeperException with error code KeeperException.BadVersion will be\n+     * thrown if the given aclVersion does not match the node's aclVersion.\n+     *\n+     * @param path the given path for the node\n+     * @param acl the given acl for the node\n+     * @param aclVersion the given acl version of the node\n+     * @return the stat of the node.\n+     * @throws InterruptedException If the server transaction is interrupted.\n+     * @throws KeeperException If the server signals an error with a non-zero error code.\n+     * @throws org.apache.zookeeper.KeeperException.InvalidACLException If the acl is invalid.\n+     * @throws IllegalArgumentException if an invalid path is specified\n+     */\n+    Stat setACL(String path, List<ACL> acl, int aclVersion) throws KeeperException, InterruptedException;\n+\n+    /**\n+     * The asynchronous version of setACL.\n+     *\n+     * @see #setACL(String, List, int)\n+     */\n+    void setACL(String path, List<ACL> acl, int version, AsyncCallback.StatCallback cb, Object ctx);\n+\n+    /**\n+     * Return the list of the children of the node of the given path.\n+     * <p>\n+     * If the watch is non-null and the call is successful (no exception is thrown),\n+     * a watch will be left on the node with the given path. The watch will be\n+     * triggered by a successful operation that deletes the node of the given\n+     * path or creates/delete a child under the node.\n+     * <p>\n+     * The list of children returned is not sorted and no guarantee is provided\n+     * as to its natural or lexical order.\n+     * <p>\n+     * A KeeperException with error code KeeperException.NoNode will be thrown\n+     * if no node with the given path exists.\n+     *\n+     * @param path\n+     * @param watcher explicit watcher\n+     * @return an unordered array of children of the node with the given path\n+     * @throws InterruptedException If the server transaction is interrupted.\n+     * @throws KeeperException If the server signals an error with a non-zero error code.\n+     * @throws IllegalArgumentException if an invalid path is specified\n+     */\n+    List<String> getChildren(String path, Watcher watcher) throws KeeperException, InterruptedException;\n+\n+    /**\n+     * Return the list of the children of the node of the given path.\n+     * <p>\n+     * If the watch is true and the call is successful (no exception is thrown),\n+     * a watch will be left on the node with the given path. The watch will be\n+     * triggered by a successful operation that deletes the node of the given\n+     * path or creates/delete a child under the node.\n+     * <p>\n+     * The list of children returned is not sorted and no guarantee is provided\n+     * as to its natural or lexical order.\n+     * <p>\n+     * A KeeperException with error code KeeperException.NoNode will be thrown\n+     * if no node with the given path exists.\n+     *\n+     * @param path the node path\n+     * @param watch whether need to watch this node\n+     * @return an unordered array of children of the node with the given path\n+     * @throws IllegalStateException if watch this node with a null default watcher\n+     * @throws InterruptedException If the server transaction is interrupted.\n+     * @throws KeeperException If the server signals an error with a non-zero error code.\n+     */\n+    List<String> getChildren(String path, boolean watch) throws KeeperException, InterruptedException;\n+\n+    /**\n+     * The asynchronous version of getChildren.\n+     *\n+     * @see #getChildren(String, Watcher)\n+     */\n+    void getChildren(String path, Watcher watcher, AsyncCallback.ChildrenCallback cb, Object ctx);\n+\n+    /**\n+     * The asynchronous version of getChildren.\n+     *\n+     * @throws IllegalStateException if watch this node with a null default watcher\n+     *\n+     * @see #getChildren(String, boolean)\n+     */\n+    void getChildren(String path, boolean watch, AsyncCallback.ChildrenCallback cb, Object ctx);\n+\n+    /**\n+     * For the given znode path return the stat and children list.\n+     * <p>\n+     * If the watch is non-null and the call is successful (no exception is thrown),\n+     * a watch will be left on the node with the given path. The watch will be\n+     * triggered by a successful operation that deletes the node of the given\n+     * path or creates/delete a child under the node.\n+     * <p>\n+     * The list of children returned is not sorted and no guarantee is provided\n+     * as to its natural or lexical order.\n+     * <p>\n+     * A KeeperException with error code KeeperException.NoNode will be thrown\n+     * if no node with the given path exists.\n+     *\n+     * @since 3.3.0\n+     *\n+     * @param path\n+     * @param watcher explicit watcher\n+     * @param stat stat of the znode designated by path\n+     * @return an unordered array of children of the node with the given path\n+     * @throws InterruptedException If the server transaction is interrupted.\n+     * @throws KeeperException If the server signals an error with a non-zero error code.\n+     * @throws IllegalArgumentException if an invalid path is specified\n+     */\n+    List<String> getChildren(\n+            String path,\n+            Watcher watcher,\n+            Stat stat) throws KeeperException, InterruptedException;\n+\n+    /**\n+     * For the given znode path return the stat and children list.\n+     * <p>\n+     * If the watch is true and the call is successful (no exception is thrown),\n+     * a watch will be left on the node with the given path. The watch will be\n+     * triggered by a successful operation that deletes the node of the given\n+     * path or creates/delete a child under the node.\n+     * <p>\n+     * The list of children returned is not sorted and no guarantee is provided\n+     * as to its natural or lexical order.\n+     * <p>\n+     * A KeeperException with error code KeeperException.NoNode will be thrown\n+     * if no node with the given path exists.\n+     *\n+     * @since 3.3.0\n+     *\n+     * @param path the node path\n+     * @param watch whether need to watch this node\n+     * @param stat stat of the znode designated by path\n+     * @return an unordered array of children of the node with the given path\n+     * @throws IllegalStateException if watch this node with a null default watcher\n+     * @throws InterruptedException If the server transaction is interrupted.\n+     * @throws KeeperException If the server signals an error with a non-zero\n+     *  error code.\n+     */\n+    List<String> getChildren(\n+            String path,\n+            boolean watch,\n+            Stat stat) throws KeeperException, InterruptedException;\n+\n+    /**\n+     * The asynchronous version of getChildren.\n+     *\n+     * @since 3.3.0\n+     *\n+     * @see #getChildren(String, Watcher, Stat)\n+     */\n+    void getChildren(String path, Watcher watcher, AsyncCallback.Children2Callback cb, Object ctx);\n+\n+    /**\n+     * The asynchronous version of getChildren.\n+     *\n+     * @since 3.3.0\n+     *\n+     * @throws IllegalStateException if watch this node with a null default watcher\n+     *\n+     * @see #getChildren(String, boolean, Stat)\n+     */\n+    void getChildren(String path, boolean watch, AsyncCallback.Children2Callback cb, Object ctx);\n+\n+    /**\n+     * Synchronously gets all numbers of children nodes under a specific path\n+     *\n+     * @since 3.6.0\n+     * @param path\n+     * @return Children nodes count under path\n+     * @throws KeeperException\n+     * @throws InterruptedException\n+     */\n+    int getAllChildrenNumber(String path) throws KeeperException, InterruptedException;\n+\n+    /**\n+     * Asynchronously gets all numbers of children nodes under a specific path\n+     *\n+     * @since 3.6.0\n+     * @param path\n+     */\n+    void getAllChildrenNumber(String path, AsyncCallback.AllChildrenNumberCallback cb, Object ctx);\n+\n+    /**\n+     * Synchronously gets all the ephemeral nodes  created by this session.\n+     *\n+     * @since 3.6.0\n+     *\n+     */\n+    List<String> getEphemerals() throws KeeperException, InterruptedException;\n+\n+    /**\n+     * Synchronously gets all the ephemeral nodes matching prefixPath\n+     * created by this session.  If prefixPath is \"/\" then it returns all\n+     * ephemerals\n+     *\n+     * @since 3.6.0\n+     *\n+     */\n+    List<String> getEphemerals(String prefixPath) throws KeeperException, InterruptedException;\n+\n+    /**\n+     * Asynchronously gets all the ephemeral nodes matching prefixPath\n+     * created by this session.  If prefixPath is \"/\" then it returns all\n+     * ephemerals\n+     *\n+     * @since 3.6.0\n+     *\n+     */\n+    void getEphemerals(String prefixPath, AsyncCallback.EphemeralsCallback cb, Object ctx);\n+\n+    /**\n+     * Asynchronously gets all the ephemeral nodes created by this session.\n+     * ephemerals\n+     *\n+     * @since 3.6.0\n+     *\n+     */\n+    void getEphemerals(AsyncCallback.EphemeralsCallback cb, Object ctx);\n+\n+    /**\n+     * Synchronous sync. Flushes channel between process and leader.\n+     *\n+     * @param path the given path\n+     * @throws KeeperException If the server signals an error with a non-zero error code\n+     * @throws InterruptedException If the server transaction is interrupted.\n+     * @throws IllegalArgumentException if an invalid path is specified\n+     */\n+    void sync(String path) throws KeeperException, InterruptedException;\n+\n+    /**\n+     * Asynchronous sync. Flushes channel between process and leader.\n+     * @param path\n+     * @param cb a handler for the callback\n+     * @param ctx context to be provided to the callback\n+     * @throws IllegalArgumentException if an invalid path is specified\n+     */\n+    void sync(String path, AsyncCallback.VoidCallback cb, Object ctx);\n+\n+    /**\n+     * For the given znode path, removes the specified watcher of given\n+     * watcherType.\n+     *\n+     * <p>\n+     * Watcher shouldn't be null. A successful call guarantees that, the\n+     * removed watcher won't be triggered.\n+     * </p>\n+     *\n+     * @param path\n+     *            - the path of the node\n+     * @param watcher\n+     *            - a concrete watcher\n+     * @param watcherType\n+     *            - the type of watcher to be removed\n+     * @param local\n+     *            - whether the watcher can be removed locally when there is no\n+     *            server connection\n+     * @throws InterruptedException\n+     *             if the server transaction is interrupted.\n+     * @throws KeeperException.NoWatcherException\n+     *             if no watcher exists that match the specified parameters\n+     * @throws KeeperException\n+     *             if the server signals an error with a non-zero error code.\n+     * @throws IllegalArgumentException\n+     *             if any of the following is true:\n+     *             <ul>\n+     *             <li> {@code path} is invalid\n+     *             <li> {@code watcher} is null\n+     *             </ul>\n+     *\n+     * @since 3.5.0\n+     */\n+    void removeWatches(\n\nReview Comment:\n   This method is cheating since ZOOKEEPER-1910, see ZOOKEEPER-4625.\n\n\n\n##########\nzookeeper-server/src/main/java/org/apache/zookeeper/client/ZooKeeper.java:\n##########\n@@ -0,0 +1,1122 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.zookeeper.client;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.util.List;\n+import org.apache.zookeeper.AddWatchMode;\n+import org.apache.zookeeper.AsyncCallback;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.Op;\n+import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.Transaction;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.data.ACL;\n+import org.apache.zookeeper.data.ClientInfo;\n+import org.apache.zookeeper.data.Stat;\n+import org.apache.zookeeper.server.EphemeralType;\n+\n+/**\n+ * This is the main class of ZooKeeper client library. To use a ZooKeeper\n+ * service, an application must first instantiate an object of ZooKeeper class.\n+ * All the iterations will be done by calling the methods of ZooKeeper class.\n+ * The methods of this class are thread-safe unless otherwise noted.\n+ * <p>\n+ * Once a connection to a server is established, a session ID is assigned to the\n+ * client. The client will send heart beats to the server periodically to keep\n+ * the session valid.\n+ * <p>\n+ * The application can call ZooKeeper APIs through a client as long as the\n+ * session ID of the client remains valid.\n+ * <p>\n+ * If for some reason, the client fails to send heart beats to the server for a\n+ * prolonged period of time (exceeding the sessionTimeout value, for instance),\n+ * the server will expire the session, and the session ID will become invalid.\n+ * The client object will no longer be usable. To make ZooKeeper API calls, the\n+ * application must create a new client object.\n+ * <p>\n+ * If the ZooKeeper server the client currently connects to fails or otherwise\n+ * does not respond, the client will automatically try to connect to another\n+ * server before its session ID expires. If successful, the application can\n+ * continue to use the client.\n+ * <p>\n+ * The ZooKeeper API methods are either synchronous or asynchronous. Synchronous\n+ * methods blocks until the server has responded. Asynchronous methods just queue\n+ * the request for sending and return immediately. They take a callback object that\n+ * will be executed either on successful execution of the request or on error with\n+ * an appropriate return code (rc) indicating the error.\n+ * <p>\n+ * Some successful ZooKeeper API calls can leave watches on the \"data nodes\" in\n+ * the ZooKeeper server. Other successful ZooKeeper API calls can trigger those\n+ * watches. Once a watch is triggered, an event will be delivered to the client\n+ * which left the watch at the first place. Each watch can be triggered only\n+ * once. Thus, up to one event will be delivered to a client for every watch it\n+ * leaves.\n+ * <p>\n+ * A client needs an object of a class implementing Watcher interface for\n+ * processing the events delivered to the client.\n+ *\n+ * When a client drops the current connection and re-connects to a server, all the\n+ * existing watches are considered as being triggered but the undelivered events\n+ * are lost. To emulate this, the client will generate a special event to tell\n+ * the event handler a connection has been dropped. This special event has\n+ * EventType None and KeeperState Disconnected.\n+ */\n+public interface ZooKeeper extends AutoCloseable {\n+    /**\n+     * Creates a builder with given connect string and session timeout.\n+     *\n+     * @param connectString\n+     *            comma separated host:port pairs, each corresponding to a zk\n+     *            server. e.g. \"127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002\"\n+     *            If the optional chroot suffix is used the example would look\n+     *            like: \"127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002/app/a\"\n+     *            where the client would be rooted at \"/app/a\" and all paths\n+     *            would be relative to this root - ie getting/setting/etc...\n+     *            \"/foo/bar\" would result in operations being run on\n+     *            \"/app/a/foo/bar\" (from the server perspective).\n+     * @param sessionTimeout\n+     *            session timeout\n+     */\n+    static ZooKeeperBuilder builder(String connectString, Duration sessionTimeout) {\n+        return new ZooKeeperBuilder(connectString, sessionTimeout);\n+    }\n+\n+    /**\n+     * The session id for this ZooKeeper client instance. The value returned is\n+     * not valid until the client connects to a server and may change after a\n+     * re-connect.\n+     *\n+     * <p>This method is NOT thread safe\n+     *\n+     * @return current session id\n+     */\n+    long getSessionId();\n\nReview Comment:\n   It would be nice to return typed session id with custom `toString`, so we don't have to use `Long.toHexString` everytime in logging.\n\n\n\n", "created": "2025-08-25T05:25:22.078+0000", "updated": "2025-08-25T05:25:22.078+0000", "started": "2025-08-25T05:25:22.077+0000", "timeSpent": "10m", "timeSpentSeconds": 600, "id": "980149", "issueId": "13626880"}, {"self": "https://issues.apache.org/jira/rest/api/2/issue/13626880/worklog/980172", "author": {"self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot", "name": "githubbot", "key": "githubbot", "avatarUrls": {"48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452", "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452", "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452", "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"}, "displayName": "ASF GitHub Bot", "active": true, "timeZone": "Etc/UTC"}, "updateAuthor": {"self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot", "name": "githubbot", "key": "githubbot", "avatarUrls": {"48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452", "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452", "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452", "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"}, "displayName": "ASF GitHub Bot", "active": true, "timeZone": "Etc/UTC"}, "comment": "kezhuw commented on code in PR #2308:\nURL: https://github.com/apache/zookeeper/pull/2308#discussion_r2297411541\n\n\n##########\nzookeeper-server/src/main/java/org/apache/zookeeper/client/ZooKeeper.java:\n##########\n@@ -0,0 +1,1122 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.zookeeper.client;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.util.List;\n+import org.apache.zookeeper.AddWatchMode;\n+import org.apache.zookeeper.AsyncCallback;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.Op;\n+import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.Transaction;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.data.ACL;\n+import org.apache.zookeeper.data.ClientInfo;\n+import org.apache.zookeeper.data.Stat;\n+import org.apache.zookeeper.server.EphemeralType;\n+\n+/**\n+ * This is the main class of ZooKeeper client library. To use a ZooKeeper\n+ * service, an application must first instantiate an object of ZooKeeper class.\n+ * All the iterations will be done by calling the methods of ZooKeeper class.\n+ * The methods of this class are thread-safe unless otherwise noted.\n+ * <p>\n+ * Once a connection to a server is established, a session ID is assigned to the\n+ * client. The client will send heart beats to the server periodically to keep\n+ * the session valid.\n+ * <p>\n+ * The application can call ZooKeeper APIs through a client as long as the\n+ * session ID of the client remains valid.\n+ * <p>\n+ * If for some reason, the client fails to send heart beats to the server for a\n+ * prolonged period of time (exceeding the sessionTimeout value, for instance),\n+ * the server will expire the session, and the session ID will become invalid.\n+ * The client object will no longer be usable. To make ZooKeeper API calls, the\n+ * application must create a new client object.\n+ * <p>\n+ * If the ZooKeeper server the client currently connects to fails or otherwise\n+ * does not respond, the client will automatically try to connect to another\n+ * server before its session ID expires. If successful, the application can\n+ * continue to use the client.\n+ * <p>\n+ * The ZooKeeper API methods are either synchronous or asynchronous. Synchronous\n+ * methods blocks until the server has responded. Asynchronous methods just queue\n+ * the request for sending and return immediately. They take a callback object that\n+ * will be executed either on successful execution of the request or on error with\n+ * an appropriate return code (rc) indicating the error.\n+ * <p>\n+ * Some successful ZooKeeper API calls can leave watches on the \"data nodes\" in\n+ * the ZooKeeper server. Other successful ZooKeeper API calls can trigger those\n+ * watches. Once a watch is triggered, an event will be delivered to the client\n+ * which left the watch at the first place. Each watch can be triggered only\n+ * once. Thus, up to one event will be delivered to a client for every watch it\n+ * leaves.\n+ * <p>\n+ * A client needs an object of a class implementing Watcher interface for\n+ * processing the events delivered to the client.\n+ *\n+ * When a client drops the current connection and re-connects to a server, all the\n+ * existing watches are considered as being triggered but the undelivered events\n+ * are lost. To emulate this, the client will generate a special event to tell\n+ * the event handler a connection has been dropped. This special event has\n+ * EventType None and KeeperState Disconnected.\n+ */\n+public interface ZooKeeper extends AutoCloseable {\n+    /**\n+     * Creates a builder with given connect string and session timeout.\n+     *\n+     * @param connectString\n+     *            comma separated host:port pairs, each corresponding to a zk\n+     *            server. e.g. \"127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002\"\n+     *            If the optional chroot suffix is used the example would look\n+     *            like: \"127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002/app/a\"\n+     *            where the client would be rooted at \"/app/a\" and all paths\n+     *            would be relative to this root - ie getting/setting/etc...\n+     *            \"/foo/bar\" would result in operations being run on\n+     *            \"/app/a/foo/bar\" (from the server perspective).\n+     * @param sessionTimeout\n+     *            session timeout\n+     */\n+    static ZooKeeperBuilder builder(String connectString, Duration sessionTimeout) {\n+        return new ZooKeeperBuilder(connectString, sessionTimeout);\n+    }\n+\n+    /**\n+     * The session id for this ZooKeeper client instance. The value returned is\n+     * not valid until the client connects to a server and may change after a\n+     * re-connect.\n+     *\n+     * <p>This method is NOT thread safe\n+     *\n+     * @return current session id\n+     */\n+    long getSessionId();\n+\n+    /**\n+     * The session password for this ZooKeeper client instance. The value\n+     * returned is not valid until the client connects to a server and may\n+     * change after a re-connect.\n+     *\n+     * <p>This method is NOT thread safe\n+     *\n+     * @return current session password\n+     */\n+    byte[] getSessionPasswd();\n+\n+    /**\n+     * The negotiated session timeout for this ZooKeeper client instance. The\n+     * value returned is not valid until the client connects to a server and\n+     * may change after a re-connect.\n+     *\n+     * This method is NOT thread safe\n+     *\n+     * @return current session timeout\n+     */\n+    int getSessionTimeout();\n+\n+    /**\n+     * Client config.\n+     */\n+    ZKClientConfig getClientConfig();\n+\n+    /**\n+     * Add the specified scheme:auth information to this connection.\n+     *\n+     * @param scheme auth scheme\n+     * @param auth auth data\n+     */\n+    void addAuthInfo(String scheme, byte[] auth);\n+\n+    /**\n+     * Specify the default watcher for the connection (overrides the one\n+     * specified during construction).\n+     */\n+    void register(Watcher watcher);\n+\n+    /**\n+     * This function allows a client to update the connection string by providing\n+     * a new comma separated list of host:port pairs, each corresponding to a\n+     * ZooKeeper server.\n+     * <p>\n+     * The function invokes a <a href=\"https://issues.apache.org/jira/browse/ZOOKEEPER-1355\">\n+     * probabilistic load-balancing algorithm</a> which may cause the client to disconnect from\n+     * its current host with the goal to achieve expected uniform number of connections per server\n+     * in the new list. In case the current host to which the client is connected is not in the new\n+     * list this call will always cause the connection to be dropped. Otherwise, the decision\n+     * is based on whether the number of servers has increased or decreased and by how much.\n+     * For example, if the previous connection string contained 3 hosts and now the list contains\n+     * these 3 hosts and 2 more hosts, 40% of clients connected to each of the 3 hosts will\n+     * move to one of the new hosts in order to balance the load. The algorithm will disconnect\n+     * from the current host with probability 0.4 and in this case cause the client to connect\n+     * to one of the 2 new hosts, chosen at random.\n+     * <p>\n+     * If the connection is dropped, the client moves to a special mode \"reconfigMode\" where he chooses\n+     * a new server to connect to using the probabilistic algorithm. After finding a server,\n+     * or exhausting all servers in the new list after trying all of them and failing to connect,\n+     * the client moves back to the normal mode of operation where it will pick an arbitrary server\n+     * from the connectString and attempt to connect to it. If establishment of\n+     * the connection fails, another server in the connect string will be tried\n+     * (the order is non-deterministic, as we random shuffle the list), until a\n+     * connection is established. The client will continue attempts until the\n+     * session is explicitly closed (or the session is expired by the server).\n+     * @param connectString\n+     *            comma separated host:port pairs, each corresponding to a zk\n+     *            server. e.g. \"127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002\"\n+     *            If the optional chroot suffix is used the example would look\n+     *            like: \"127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002/app/a\"\n+     *            where the client would be rooted at \"/app/a\" and all paths\n+     *            would be relative to this root - ie getting/setting/etc...\n+     *            \"/foo/bar\" would result in operations being run on\n+     *            \"/app/a/foo/bar\" (from the server perspective).\n+     *\n+     * @throws IOException in cases of network failure\n+     */\n+    void updateServerList(String connectString) throws IOException;\n+\n+    /**\n+     * Close this client object. Once the client is closed, its session becomes\n+     * invalid. All the ephemeral nodes in the ZooKeeper server associated with\n+     * the session will be removed. The watches left on those nodes (and on\n+     * their parents) will be triggered.\n+     * <p>\n+     * Added in 3.5.3: <a href=\"https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html\">try-with-resources</a>\n+     * may be used instead of calling close directly.\n+     * </p>\n+     * <p>\n+     * This method does not wait for all internal threads to exit.\n+     * Use the {@link #close(int) } method to wait for all resources to be released\n+     * </p>\n+     *\n+     * @throws InterruptedException\n+     */\n+    void close() throws InterruptedException;\n+\n+    /**\n+     * Close this client object as the {@link #close() } method.\n+     * This method will wait for internal resources to be released.\n+     *\n+     * @param waitForShutdownTimeoutMs timeout (in milliseconds) to wait for resources to be released.\n+     * Use zero or a negative value to skip the wait\n+     * @throws InterruptedException\n+     * @return true if waitForShutdownTimeout is greater than zero and all of the resources have been released\n+     *\n+     * @since 3.5.4\n+     */\n+    boolean close(int waitForShutdownTimeoutMs) throws InterruptedException;\n+\n+    /**\n+     * Create a node with the given path. The node data will be the given data,\n+     * and node acl will be the given acl.\n+     * <p>\n+     * The flags argument specifies whether the created node will be ephemeral\n+     * or not.\n+     * <p>\n+     * An ephemeral node will be removed by the ZooKeeper automatically when the\n+     * session associated with the creation of the node expires.\n+     * <p>\n+     * The flags argument can also specify to create a sequential node. The\n+     * actual path name of a sequential node will be the given path plus a\n+     * suffix \"i\" where i is the current sequential number of the node. The sequence\n+     * number is always fixed length of 10 digits, 0 padded. Once\n+     * such a node is created, the sequential number will be incremented by one.\n+     * <p>\n+     * If a node with the same actual path already exists in the ZooKeeper, a\n+     * KeeperException with error code KeeperException.NodeExists will be\n+     * thrown. Note that since a different actual path is used for each\n+     * invocation of creating sequential node with the same path argument, the\n+     * call will never throw \"file exists\" KeeperException.\n+     * <p>\n+     * If the parent node does not exist in the ZooKeeper, a KeeperException\n+     * with error code KeeperException.NoNode will be thrown.\n+     * <p>\n+     * An ephemeral node cannot have children. If the parent node of the given\n+     * path is ephemeral, a KeeperException with error code\n+     * KeeperException.NoChildrenForEphemerals will be thrown.\n+     * <p>\n+     * This operation, if successful, will trigger all the watches left on the\n+     * node of the given path by exists and getData API calls, and the watches\n+     * left on the parent node by getChildren API calls.\n+     * <p>\n+     * If a node is created successfully, the ZooKeeper server will trigger the\n+     * watches on the path left by exists calls, and the watches on the parent\n+     * of the node by getChildren calls.\n+     * <p>\n+     * The maximum allowable size of the data array is 1 MB (1,048,576 bytes).\n+     * Arrays larger than this will cause a KeeperException to be thrown.\n+     *\n+     * @param path\n+     *                the path for the node\n+     * @param data\n+     *                the initial data for the node\n+     * @param acl\n+     *                the acl for the node\n+     * @param createMode\n+     *                specifying whether the node to be created is ephemeral\n+     *                and/or sequential\n+     * @return the actual path of the created node\n+     * @throws KeeperException if the server returns a non-zero error code\n+     * @throws KeeperException.InvalidACLException if the ACL is invalid, null, or empty\n+     * @throws InterruptedException if the transaction is interrupted\n+     * @throws IllegalArgumentException if an invalid path is specified\n+     */\n+    String create(\n+            String path,\n+            byte[] data,\n+            List<ACL> acl,\n+            CreateMode createMode) throws KeeperException, InterruptedException;\n+\n+    /**\n+     * Create a node with the given path and returns the Stat of that node. The\n+     * node data will be the given data and node acl will be the given acl.\n+     * <p>\n+     * The flags argument specifies whether the created node will be ephemeral\n+     * or not.\n+     * <p>\n+     * An ephemeral node will be removed by the ZooKeeper automatically when the\n+     * session associated with the creation of the node expires.\n+     * <p>\n+     * The flags argument can also specify to create a sequential node. The\n+     * actual path name of a sequential node will be the given path plus a\n+     * suffix \"i\" where i is the current sequential number of the node. The sequence\n+     * number is always fixed length of 10 digits, 0 padded. Once\n+     * such a node is created, the sequential number will be incremented by one.\n+     * <p>\n+     * If a node with the same actual path already exists in the ZooKeeper, a\n+     * KeeperException with error code KeeperException.NodeExists will be\n+     * thrown. Note that since a different actual path is used for each\n+     * invocation of creating sequential node with the same path argument, the\n+     * call will never throw \"file exists\" KeeperException.\n+     * <p>\n+     * If the parent node does not exist in the ZooKeeper, a KeeperException\n+     * with error code KeeperException.NoNode will be thrown.\n+     * <p>\n+     * An ephemeral node cannot have children. If the parent node of the given\n+     * path is ephemeral, a KeeperException with error code\n+     * KeeperException.NoChildrenForEphemerals will be thrown.\n+     * <p>\n+     * This operation, if successful, will trigger all the watches left on the\n+     * node of the given path by exists and getData API calls, and the watches\n+     * left on the parent node by getChildren API calls.\n+     * <p>\n+     * If a node is created successfully, the ZooKeeper server will trigger the\n+     * watches on the path left by exists calls, and the watches on the parent\n+     * of the node by getChildren calls.\n+     * <p>\n+     * The maximum allowable size of the data array is 1 MB (1,048,576 bytes).\n+     * Arrays larger than this will cause a KeeperException to be thrown.\n+     *\n+     * @param path\n+     *                the path for the node\n+     * @param data\n+     *                the initial data for the node\n+     * @param acl\n+     *                the acl for the node\n+     * @param createMode\n+     *                specifying whether the node to be created is ephemeral\n+     *                and/or sequential\n+     * @param stat\n+     *                The output Stat object.\n+     * @return the actual path of the created node\n+     * @throws KeeperException if the server returns a non-zero error code\n+     * @throws KeeperException.InvalidACLException if the ACL is invalid, null, or empty\n+     * @throws InterruptedException if the transaction is interrupted\n+     * @throws IllegalArgumentException if an invalid path is specified\n+     */\n+    String create(\n+            String path,\n+            byte[] data,\n+            List<ACL> acl,\n+            CreateMode createMode,\n+            Stat stat) throws KeeperException, InterruptedException;\n+\n+    /**\n+     * same as {@link #create(String, byte[], List, CreateMode, Stat)} but\n+     * allows for specifying a TTL when mode is {@link CreateMode#PERSISTENT_WITH_TTL}\n+     * or {@link CreateMode#PERSISTENT_SEQUENTIAL_WITH_TTL}. If the znode has not been modified\n+     * within the given TTL, it will be deleted once it has no children. The TTL unit is\n+     * milliseconds and must be greater than 0 and less than or equal to\n+     * {@link EphemeralType#maxValue()} for {@link EphemeralType#TTL}.\n+     */\n+    String create(\n+            String path,\n+            byte[] data,\n+            List<ACL> acl,\n+            CreateMode createMode,\n+            Stat stat,\n+            long ttl) throws KeeperException, InterruptedException;\n+\n+    /**\n+     * The asynchronous version of create.\n+     *\n+     * @see #create(String, byte[], List, CreateMode)\n+     */\n+    void create(\n+            String path,\n+            byte[] data,\n+            List<ACL> acl,\n+            CreateMode createMode,\n+            AsyncCallback.StringCallback cb,\n+            Object ctx);\n+\n+    /**\n+     * The asynchronous version of create.\n+     *\n+     * @see #create(String, byte[], List, CreateMode, Stat)\n+     */\n+    void create(\n+            String path,\n+            byte[] data,\n+            List<ACL> acl,\n+            CreateMode createMode,\n+            AsyncCallback.Create2Callback cb,\n+            Object ctx);\n+\n+    /**\n+     * The asynchronous version of create with ttl.\n+     *\n+     * @see #create(String, byte[], List, CreateMode, Stat, long)\n+     */\n+    void create(\n+            String path,\n+            byte[] data,\n+            List<ACL> acl,\n+            CreateMode createMode,\n+            AsyncCallback.Create2Callback cb,\n+            Object ctx,\n+            long ttl);\n+\n+    /**\n+     * Return the stat of the node of the given path. Return null if no such a\n+     * node exists.\n+     * <p>\n+     * If the watch is non-null and the call is successful (no exception is thrown),\n+     * a watch will be left on the node with the given path. The watch will be\n+     * triggered by a successful operation that creates/delete the node or sets\n+     * the data on the node.\n+     *\n+     * @param path the node path\n+     * @param watcher explicit watcher\n+     * @return the stat of the node of the given path; return null if no such a\n+     *         node exists.\n+     * @throws KeeperException If the server signals an error\n+     * @throws InterruptedException If the server transaction is interrupted.\n+     * @throws IllegalArgumentException if an invalid path is specified\n+     */\n+    Stat exists(String path, Watcher watcher) throws KeeperException, InterruptedException;\n+\n+    /**\n+     * Return the stat of the node of the given path. Return null if no such a\n+     * node exists.\n+     *\n+     * <p>If the watch is true and the call is successful (no exception is thrown),\n+     * a watch will be left on the node with the given path. The watch will be\n+     * triggered by a successful operation that creates/delete the node or sets\n+     * the data on the node.\n+     *\n+     * @param path the node path\n+     * @param watch whether need to watch this node\n+     * @return the stat of the node of the given path; return null if no such a\n+     *         node exists.\n+     * @throws KeeperException If the server signals an error\n+     * @throws IllegalStateException if watch this node with a null default watcher\n+     * @throws InterruptedException If the server transaction is interrupted.\n+     */\n+    Stat exists(String path, boolean watch) throws KeeperException, InterruptedException;\n+\n+    /**\n+     * The asynchronous version of exists.\n+     *\n+     * @see #exists(String, Watcher)\n+     */\n+    void exists(String path, Watcher watcher, AsyncCallback.StatCallback cb, Object ctx);\n+\n+    /**\n+     * The asynchronous version of exists.\n+     *\n+     * @throws IllegalStateException if watch this node with a null default watcher\n+     *\n+     * @see #exists(String, boolean)\n+     */\n+    void exists(String path, boolean watch, AsyncCallback.StatCallback cb, Object ctx);\n+\n+    /**\n+     * Delete the node with the given path. The call will succeed if such a node\n+     * exists, and the given version matches the node's version (if the given\n+     * version is -1, it matches any node's versions).\n+     * <p>\n+     * A KeeperException with error code KeeperException.NoNode will be thrown\n+     * if the nodes does not exist.\n+     * <p>\n+     * A KeeperException with error code KeeperException.BadVersion will be\n+     * thrown if the given version does not match the node's version.\n+     * <p>\n+     * A KeeperException with error code KeeperException.NotEmpty will be thrown\n+     * if the node has children.\n+     * <p>\n+     * This operation, if successful, will trigger all the watches on the node\n+     * of the given path left by exists API calls, and the watches on the parent\n+     * node left by getChildren API calls.\n+     *\n+     * @param path\n+     *                the path of the node to be deleted.\n+     * @param version\n+     *                the expected node version.\n+     * @throws InterruptedException IF the server transaction is interrupted\n+     * @throws KeeperException If the server signals an error with a non-zero\n+     *   return code.\n+     * @throws IllegalArgumentException if an invalid path is specified\n+     */\n+    void delete(String path, int version) throws InterruptedException, KeeperException;\n+\n+    /**\n+     * The asynchronous version of delete.\n+     *\n+     * @see #delete(String, int)\n+     */\n+    void delete(String path, int version, AsyncCallback.VoidCallback cb, Object ctx);\n+\n+    /**\n+     * Executes multiple ZooKeeper operations. In case of transactions all of them or none of them will be executed.\n+     * <p>\n+     * On success, a list of results is returned.\n+     * On failure, an exception is raised which contains partial results and\n+     * error details, see {@link KeeperException#getResults}\n+     * <p>\n+     * Note: The maximum allowable size of all of the data arrays in all of\n+     * the setData operations in this single request is typically 1 MB\n+     * (1,048,576 bytes). This limit is specified on the server via\n+     * <a href=\"http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#Unsafe+Options\">jute.maxbuffer</a>.\n+     * Requests larger than this will cause a KeeperException to be\n+     * thrown.\n+     *\n+     * @param ops An iterable that contains the operations to be done.\n+     * These should be created using the factory methods on {@link Op} and must be the same kind of ops.\n+     * @return A list of results, one for each input Op, the order of\n+     * which exactly matches the order of the <code>ops</code> input\n+     * operations.\n+     * @throws InterruptedException If the operation was interrupted.\n+     * The operation may or may not have succeeded, but will not have\n+     * partially succeeded if this exception is thrown.\n+     * @throws KeeperException If the operation could not be completed\n+     * due to some error in doing one of the specified ops.\n+     * @throws IllegalArgumentException if an invalid path is specified or different kind of ops are mixed\n+     *\n+     * @since 3.4.0\n+     */\n+    List<OpResult> multi(Iterable<Op> ops) throws InterruptedException, KeeperException;\n+\n+    /**\n+     * The asynchronous version of multi.\n+     *\n+     * @see #multi(Iterable)\n+     */\n+    void multi(Iterable<Op> ops, AsyncCallback.MultiCallback cb, Object ctx);\n+\n+    /**\n+     * Return the data and the stat of the node of the given path.\n+     * <p>\n+     * If the watch is non-null and the call is successful (no exception is\n+     * thrown), a watch will be left on the node with the given path. The watch\n+     * will be triggered by a successful operation that sets data on the node, or\n+     * deletes the node.\n+     * <p>\n+     * A KeeperException with error code KeeperException.NoNode will be thrown\n+     * if no node with the given path exists.\n+     *\n+     * @param path the given path\n+     * @param watcher explicit watcher\n+     * @param stat the stat of the node\n+     * @return the data of the node\n+     * @throws KeeperException If the server signals an error with a non-zero error code\n+     * @throws InterruptedException If the server transaction is interrupted.\n+     * @throws IllegalArgumentException if an invalid path is specified\n+     */\n+    byte[] getData(String path, Watcher watcher, Stat stat) throws KeeperException, InterruptedException;\n+\n+    /**\n+     * Return the data and the stat of the node of the given path.\n+     * <p>\n+     * If the watch is true and the call is successful (no exception is\n+     * thrown), a watch will be left on the node with the given path. The watch\n+     * will be triggered by a successful operation that sets data on the node, or\n+     * deletes the node.\n+     * <p>\n+     * A KeeperException with error code KeeperException.NoNode will be thrown\n+     * if no node with the given path exists.\n+     *\n+     * @param path the given path\n+     * @param watch whether need to watch this node\n+     * @param stat the stat of the node\n+     * @return the data of the node\n+     * @throws KeeperException If the server signals an error with a non-zero error code\n+     * @throws IllegalStateException if watch this node with a null default watcher\n+     * @throws InterruptedException If the server transaction is interrupted.\n+     */\n+    byte[] getData(String path, boolean watch, Stat stat) throws KeeperException, InterruptedException;\n+\n+    /**\n+     * The asynchronous version of getData.\n+     *\n+     * @see #getData(String, Watcher, Stat)\n+     */\n+    void getData(String path, Watcher watcher, AsyncCallback.DataCallback cb, Object ctx);\n+\n+    /**\n+     * The asynchronous version of getData.\n+     *\n+     * @throws IllegalStateException if watch this node with a null default watcher\n+     *\n+     * @see #getData(String, boolean, Stat)\n+     */\n+    void getData(String path, boolean watch, AsyncCallback.DataCallback cb, Object ctx);\n+\n+    /**\n+     * Return the last committed configuration (as known to the server to which the client is connected)\n+     * and the stat of the configuration.\n+     * <p>\n+     * If the watch is non-null and the call is successful (no exception is\n+     * thrown), a watch will be left on the configuration node (ZooDefs.CONFIG_NODE). The watch\n+     * will be triggered by a successful reconfig operation\n+     * <p>\n+     * A KeeperException with error code KeeperException.NoNode will be thrown\n+     * if the configuration node doesn't exists.\n+     *\n+     * @param watcher explicit watcher\n+     * @param stat the stat of the configuration node ZooDefs.CONFIG_NODE\n+     * @return configuration data stored in ZooDefs.CONFIG_NODE\n+     * @throws KeeperException If the server signals an error with a non-zero error code\n+     * @throws InterruptedException If the server transaction is interrupted.\n+     */\n+    byte[] getConfig(Watcher watcher, Stat stat) throws KeeperException, InterruptedException;\n+\n+    /**\n+     * The asynchronous version of getConfig.\n+     *\n+     * @see #getConfig(Watcher, Stat)\n+     */\n+    void getConfig(Watcher watcher, AsyncCallback.DataCallback cb, Object ctx);\n+\n+    /**\n+     * Return the last committed configuration (as known to the server to which the client is connected)\n+     * and the stat of the configuration.\n+     * <p>\n+     * If the watch is true and the call is successful (no exception is\n+     * thrown), a watch will be left on the configuration node (ZooDefs.CONFIG_NODE). The watch\n+     * will be triggered by a successful reconfig operation\n+     * <p>\n+     * A KeeperException with error code KeeperException.NoNode will be thrown\n+     * if no node with the given path exists.\n+     *\n+     * @param watch whether need to watch this node\n+     * @param stat the stat of the configuration node ZooDefs.CONFIG_NODE\n+     * @return configuration data stored in ZooDefs.CONFIG_NODE\n+     * @throws KeeperException If the server signals an error with a non-zero error code\n+     * @throws IllegalStateException if watch this node with a null default watcher\n+     * @throws InterruptedException If the server transaction is interrupted.\n+     */\n+    byte[] getConfig(boolean watch, Stat stat) throws KeeperException, InterruptedException;\n+\n+    /**\n+     * The Asynchronous version of getConfig.\n+     *\n+     * @throws IllegalStateException if watch this node with a null default watcher\n+     *\n+     * @see #getData(String, boolean, Stat)\n+     */\n+    void getConfig(boolean watch, AsyncCallback.DataCallback cb, Object ctx);\n+\n+    /**\n+     * Set the data for the node of the given path if such a node exists and the\n+     * given version matches the version of the node (if the given version is\n+     * -1, it matches any node's versions). Return the stat of the node.\n+     * <p>\n+     * This operation, if successful, will trigger all the watches on the node\n+     * of the given path left by getData calls.\n+     * <p>\n+     * A KeeperException with error code KeeperException.NoNode will be thrown\n+     * if no node with the given path exists.\n+     * <p>\n+     * A KeeperException with error code KeeperException.BadVersion will be\n+     * thrown if the given version does not match the node's version.\n+     * <p>\n+     * The maximum allowable size of the data array is 1 MB (1,048,576 bytes).\n+     * Arrays larger than this will cause a KeeperException to be thrown.\n+     *\n+     * @param path\n+     *                the path of the node\n+     * @param data\n+     *                the data to set\n+     * @param version\n+     *                the expected matching version\n+     * @return the state of the node\n+     * @throws InterruptedException If the server transaction is interrupted.\n+     * @throws KeeperException If the server signals an error with a non-zero error code.\n+     * @throws IllegalArgumentException if an invalid path is specified\n+     */\n+    Stat setData(String path, byte[] data, int version) throws KeeperException, InterruptedException;\n+\n+    /**\n+     * The asynchronous version of setData.\n+     *\n+     * @see #setData(String, byte[], int)\n+     */\n+    void setData(String path, byte[] data, int version, AsyncCallback.StatCallback cb, Object ctx);\n+\n+    /**\n+     * Return the ACL and stat of the node of the given path.\n+     * <p>\n+     * A KeeperException with error code KeeperException.NoNode will be thrown\n+     * if no node with the given path exists.\n+     *\n+     * @param path\n+     *                the given path for the node\n+     * @param stat\n+     *                the stat of the node will be copied to this parameter if\n+     *                not null.\n+     * @return the ACL array of the given node.\n+     * @throws InterruptedException If the server transaction is interrupted.\n+     * @throws KeeperException If the server signals an error with a non-zero error code.\n+     * @throws IllegalArgumentException if an invalid path is specified\n+     */\n+    List<ACL> getACL(String path, Stat stat) throws KeeperException, InterruptedException;\n+\n+    /**\n+     * The asynchronous version of getACL.\n+     *\n+     * @see #getACL(String, Stat)\n+     */\n+    void getACL(String path, Stat stat, AsyncCallback.ACLCallback cb, Object ctx);\n+\n+    /**\n+     * Set the ACL for the node of the given path if such a node exists and the\n+     * given aclVersion matches the acl version of the node. Return the stat of the\n+     * node.\n+     * <p>\n+     * A KeeperException with error code KeeperException.NoNode will be thrown\n+     * if no node with the given path exists.\n+     * <p>\n+     * A KeeperException with error code KeeperException.BadVersion will be\n+     * thrown if the given aclVersion does not match the node's aclVersion.\n+     *\n+     * @param path the given path for the node\n+     * @param acl the given acl for the node\n+     * @param aclVersion the given acl version of the node\n+     * @return the stat of the node.\n+     * @throws InterruptedException If the server transaction is interrupted.\n+     * @throws KeeperException If the server signals an error with a non-zero error code.\n+     * @throws org.apache.zookeeper.KeeperException.InvalidACLException If the acl is invalid.\n+     * @throws IllegalArgumentException if an invalid path is specified\n+     */\n+    Stat setACL(String path, List<ACL> acl, int aclVersion) throws KeeperException, InterruptedException;\n+\n+    /**\n+     * The asynchronous version of setACL.\n+     *\n+     * @see #setACL(String, List, int)\n+     */\n+    void setACL(String path, List<ACL> acl, int version, AsyncCallback.StatCallback cb, Object ctx);\n+\n+    /**\n+     * Return the list of the children of the node of the given path.\n+     * <p>\n+     * If the watch is non-null and the call is successful (no exception is thrown),\n+     * a watch will be left on the node with the given path. The watch will be\n+     * triggered by a successful operation that deletes the node of the given\n+     * path or creates/delete a child under the node.\n+     * <p>\n+     * The list of children returned is not sorted and no guarantee is provided\n+     * as to its natural or lexical order.\n+     * <p>\n+     * A KeeperException with error code KeeperException.NoNode will be thrown\n+     * if no node with the given path exists.\n+     *\n+     * @param path\n+     * @param watcher explicit watcher\n+     * @return an unordered array of children of the node with the given path\n+     * @throws InterruptedException If the server transaction is interrupted.\n+     * @throws KeeperException If the server signals an error with a non-zero error code.\n+     * @throws IllegalArgumentException if an invalid path is specified\n+     */\n+    List<String> getChildren(String path, Watcher watcher) throws KeeperException, InterruptedException;\n+\n+    /**\n+     * Return the list of the children of the node of the given path.\n+     * <p>\n+     * If the watch is true and the call is successful (no exception is thrown),\n+     * a watch will be left on the node with the given path. The watch will be\n+     * triggered by a successful operation that deletes the node of the given\n+     * path or creates/delete a child under the node.\n+     * <p>\n+     * The list of children returned is not sorted and no guarantee is provided\n+     * as to its natural or lexical order.\n+     * <p>\n+     * A KeeperException with error code KeeperException.NoNode will be thrown\n+     * if no node with the given path exists.\n+     *\n+     * @param path the node path\n+     * @param watch whether need to watch this node\n+     * @return an unordered array of children of the node with the given path\n+     * @throws IllegalStateException if watch this node with a null default watcher\n+     * @throws InterruptedException If the server transaction is interrupted.\n+     * @throws KeeperException If the server signals an error with a non-zero error code.\n+     */\n+    List<String> getChildren(String path, boolean watch) throws KeeperException, InterruptedException;\n+\n+    /**\n+     * The asynchronous version of getChildren.\n+     *\n+     * @see #getChildren(String, Watcher)\n+     */\n+    void getChildren(String path, Watcher watcher, AsyncCallback.ChildrenCallback cb, Object ctx);\n+\n+    /**\n+     * The asynchronous version of getChildren.\n+     *\n+     * @throws IllegalStateException if watch this node with a null default watcher\n+     *\n+     * @see #getChildren(String, boolean)\n+     */\n+    void getChildren(String path, boolean watch, AsyncCallback.ChildrenCallback cb, Object ctx);\n+\n+    /**\n+     * For the given znode path return the stat and children list.\n+     * <p>\n+     * If the watch is non-null and the call is successful (no exception is thrown),\n+     * a watch will be left on the node with the given path. The watch will be\n+     * triggered by a successful operation that deletes the node of the given\n+     * path or creates/delete a child under the node.\n+     * <p>\n+     * The list of children returned is not sorted and no guarantee is provided\n+     * as to its natural or lexical order.\n+     * <p>\n+     * A KeeperException with error code KeeperException.NoNode will be thrown\n+     * if no node with the given path exists.\n+     *\n+     * @since 3.3.0\n+     *\n+     * @param path\n+     * @param watcher explicit watcher\n+     * @param stat stat of the znode designated by path\n+     * @return an unordered array of children of the node with the given path\n+     * @throws InterruptedException If the server transaction is interrupted.\n+     * @throws KeeperException If the server signals an error with a non-zero error code.\n+     * @throws IllegalArgumentException if an invalid path is specified\n+     */\n+    List<String> getChildren(\n+            String path,\n+            Watcher watcher,\n+            Stat stat) throws KeeperException, InterruptedException;\n+\n+    /**\n+     * For the given znode path return the stat and children list.\n+     * <p>\n+     * If the watch is true and the call is successful (no exception is thrown),\n+     * a watch will be left on the node with the given path. The watch will be\n+     * triggered by a successful operation that deletes the node of the given\n+     * path or creates/delete a child under the node.\n+     * <p>\n+     * The list of children returned is not sorted and no guarantee is provided\n+     * as to its natural or lexical order.\n+     * <p>\n+     * A KeeperException with error code KeeperException.NoNode will be thrown\n+     * if no node with the given path exists.\n+     *\n+     * @since 3.3.0\n+     *\n+     * @param path the node path\n+     * @param watch whether need to watch this node\n+     * @param stat stat of the znode designated by path\n+     * @return an unordered array of children of the node with the given path\n+     * @throws IllegalStateException if watch this node with a null default watcher\n+     * @throws InterruptedException If the server transaction is interrupted.\n+     * @throws KeeperException If the server signals an error with a non-zero\n+     *  error code.\n+     */\n+    List<String> getChildren(\n+            String path,\n+            boolean watch,\n+            Stat stat) throws KeeperException, InterruptedException;\n+\n+    /**\n+     * The asynchronous version of getChildren.\n+     *\n+     * @since 3.3.0\n+     *\n+     * @see #getChildren(String, Watcher, Stat)\n+     */\n+    void getChildren(String path, Watcher watcher, AsyncCallback.Children2Callback cb, Object ctx);\n+\n+    /**\n+     * The asynchronous version of getChildren.\n+     *\n+     * @since 3.3.0\n+     *\n+     * @throws IllegalStateException if watch this node with a null default watcher\n+     *\n+     * @see #getChildren(String, boolean, Stat)\n+     */\n+    void getChildren(String path, boolean watch, AsyncCallback.Children2Callback cb, Object ctx);\n+\n+    /**\n+     * Synchronously gets all numbers of children nodes under a specific path\n+     *\n+     * @since 3.6.0\n+     * @param path\n+     * @return Children nodes count under path\n+     * @throws KeeperException\n+     * @throws InterruptedException\n+     */\n+    int getAllChildrenNumber(String path) throws KeeperException, InterruptedException;\n+\n+    /**\n+     * Asynchronously gets all numbers of children nodes under a specific path\n+     *\n+     * @since 3.6.0\n+     * @param path\n+     */\n+    void getAllChildrenNumber(String path, AsyncCallback.AllChildrenNumberCallback cb, Object ctx);\n+\n+    /**\n+     * Synchronously gets all the ephemeral nodes  created by this session.\n+     *\n+     * @since 3.6.0\n+     *\n+     */\n+    List<String> getEphemerals() throws KeeperException, InterruptedException;\n+\n+    /**\n+     * Synchronously gets all the ephemeral nodes matching prefixPath\n+     * created by this session.  If prefixPath is \"/\" then it returns all\n+     * ephemerals\n+     *\n+     * @since 3.6.0\n+     *\n+     */\n+    List<String> getEphemerals(String prefixPath) throws KeeperException, InterruptedException;\n+\n+    /**\n+     * Asynchronously gets all the ephemeral nodes matching prefixPath\n+     * created by this session.  If prefixPath is \"/\" then it returns all\n+     * ephemerals\n+     *\n+     * @since 3.6.0\n+     *\n+     */\n+    void getEphemerals(String prefixPath, AsyncCallback.EphemeralsCallback cb, Object ctx);\n+\n+    /**\n+     * Asynchronously gets all the ephemeral nodes created by this session.\n+     * ephemerals\n+     *\n+     * @since 3.6.0\n+     *\n+     */\n+    void getEphemerals(AsyncCallback.EphemeralsCallback cb, Object ctx);\n+\n+    /**\n+     * Synchronous sync. Flushes channel between process and leader.\n+     *\n+     * @param path the given path\n+     * @throws KeeperException If the server signals an error with a non-zero error code\n+     * @throws InterruptedException If the server transaction is interrupted.\n+     * @throws IllegalArgumentException if an invalid path is specified\n+     */\n+    void sync(String path) throws KeeperException, InterruptedException;\n+\n+    /**\n+     * Asynchronous sync. Flushes channel between process and leader.\n+     * @param path\n+     * @param cb a handler for the callback\n+     * @param ctx context to be provided to the callback\n+     * @throws IllegalArgumentException if an invalid path is specified\n+     */\n+    void sync(String path, AsyncCallback.VoidCallback cb, Object ctx);\n+\n+    /**\n+     * For the given znode path, removes the specified watcher of given\n+     * watcherType.\n+     *\n+     * <p>\n+     * Watcher shouldn't be null. A successful call guarantees that, the\n+     * removed watcher won't be triggered.\n+     * </p>\n+     *\n+     * @param path\n+     *            - the path of the node\n+     * @param watcher\n+     *            - a concrete watcher\n+     * @param watcherType\n+     *            - the type of watcher to be removed\n+     * @param local\n+     *            - whether the watcher can be removed locally when there is no\n+     *            server connection\n+     * @throws InterruptedException\n+     *             if the server transaction is interrupted.\n+     * @throws KeeperException.NoWatcherException\n+     *             if no watcher exists that match the specified parameters\n+     * @throws KeeperException\n+     *             if the server signals an error with a non-zero error code.\n+     * @throws IllegalArgumentException\n+     *             if any of the following is true:\n+     *             <ul>\n+     *             <li> {@code path} is invalid\n+     *             <li> {@code watcher} is null\n+     *             </ul>\n+     *\n+     * @since 3.5.0\n+     */\n+    void removeWatches(\n\nReview Comment:\n   > The difference with the earlier api is,\r\n   >\r\n   > (1)this won't remove the given watcher from the server set even if the watcher set is empty, but it will remove the reference from the zkclient. This api will invoke a call to server and maintain orderly execution as earlier. IMHO sending to server is required to handle packet in-flight cases.\r\n   > (2)null watcher is not allowed, client will validate and throw IllegalArgumentException.\r\n   \r\n   We are now have persistent watcher now, it will continue event delivery until removed. If we are going to use new interface, it is a chance for us to reevaluate this api.\n\n\n\n", "created": "2025-08-25T08:07:42.251+0000", "updated": "2025-08-25T08:07:42.251+0000", "started": "2025-08-25T08:07:42.251+0000", "timeSpent": "10m", "timeSpentSeconds": 600, "id": "980172", "issueId": "13626880"}]}, "archivedby": null, "customfield_12313920": null, "issuetype": {"self": "https://issues.apache.org/jira/rest/api/2/issuetype/2", "id": "2", "description": "A new feature of the product, which has yet to be developed.", "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype", "name": "New Feature", "subtask": false, "avatarId": 21141}, "timespent": 2400, "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@1d487c59[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3eda3190[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@62e130d[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@6997e4e9[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4cec627d[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@44094855[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@32498da2[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@642f87ae[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4b7ffedc[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@453a4c06[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3be0ed9e[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@23ea0fbb[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}", "customfield_12314141": null, "customfield_12314140": null, "project": {"self": "https://issues.apache.org/jira/rest/api/2/project/12310801", "id": "12310801", "key": "ZOOKEEPER", "name": "ZooKeeper", "projectTypeKey": "software", "avatarUrls": {"48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12310801&avatarId=10011", "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12310801&avatarId=10011", "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12310801&avatarId=10011", "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12310801&avatarId=10011"}, "projectCategory": {"self": "https://issues.apache.org/jira/rest/api/2/projectCategory/10484", "id": "10484", "description": "Apache ZooKeeper related", "name": "ZooKeeper"}}, "aggregatetimespent": 2400, "customfield_12312520": null, "customfield_12312521": "Wed Aug 20 22:18:56 UTC 2025", "customfield_12314422": null, "customfield_12314421": null, "customfield_12314146": null, "customfield_12314420": null, "customfield_12314145": null, "customfield_12314144": null, "customfield_12314143": null, "resolutiondate": null, "workratio": -1, "customfield_12312923": null, "customfield_12312920": null, "customfield_12312921": null, "watches": {"self": "https://issues.apache.org/jira/rest/api/2/issue/ZOOKEEPER-4968/watchers", "watchCount": 2, "isWatching": false}, "created": "2025-08-20T17:04:16.000+0000", "customfield_12310192": null, "customfield_12310191": null, "customfield_12310230": null, "updated": "2025-08-25T08:07:42.000+0000", "timeoriginalestimate": null, "description": "I think it is feasible even in 3.x with helper from {{ZooKeeperBuilder}}. But that prabably be abi incompatible.", "customfield_10010": null, "timetracking": {"remainingEstimate": "0h", "timeSpent": "40m", "remainingEstimateSeconds": 0, "timeSpentSeconds": 2400}, "customfield_12314523": null, "customfield_12314127": null, "customfield_12314522": null, "customfield_12314126": null, "customfield_12314521": null, "customfield_12314125": null, "customfield_12314520": null, "customfield_12314124": null, "customfield_12312340": null, "attachment": [], "customfield_12314123": null, "customfield_12312341": null, "customfield_12312220": null, "customfield_12314122": null, "customfield_12314121": null, "customfield_12314120": null, "customfield_12314129": null, "customfield_12314524": null, "customfield_12314128": null, "summary": "Introduce interface to cover ZooKeeper client operations", "customfield_12314130": null, "customfield_12310291": null, "customfield_12310290": null, "customfield_12311024": null, "customfield_12314138": null, "customfield_12314137": null, "environment": null, "customfield_12314136": null, "customfield_12314135": null, "customfield_12311020": null, "customfield_12314134": null, "duedate": null, "customfield_12314132": null, "customfield_12314131": null, "comment": {"comments": [{"self": "https://issues.apache.org/jira/rest/api/2/issue/13626880/comment/18015282", "id": "18015282", "author": {"self": "https://issues.apache.org/jira/rest/api/2/user?username=ctubbsii", "name": "ctubbsii", "key": "ctubbsii", "avatarUrls": {"48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=ctubbsii&avatarId=15840", "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=ctubbsii&avatarId=15840", "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=ctubbsii&avatarId=15840", "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=ctubbsii&avatarId=15840"}, "displayName": "Christopher Tubbs", "active": true, "timeZone": "America/New_York"}, "body": "For my application, I created a wrapper ZooSession object that wraps ZooKeeper and handles replacing the ZooKeeper object internally when it experiences a session expiration, since the ZooKeeper client object is typically useless after a session expiration. However, I only implemented a subset of ZooKeeper's methods, to proxy, because I only used a few. It would be great to have an interface for ZooKeeper that defined the client API. Then I could have my own wrapper object implement that interface, so my automatic-reconnecting client could be used anywhere the usual ZooKeeper client object is used, as a drop-in replacement.", "updateAuthor": {"self": "https://issues.apache.org/jira/rest/api/2/user?username=ctubbsii", "name": "ctubbsii", "key": "ctubbsii", "avatarUrls": {"48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=ctubbsii&avatarId=15840", "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=ctubbsii&avatarId=15840", "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=ctubbsii&avatarId=15840", "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=ctubbsii&avatarId=15840"}, "displayName": "Christopher Tubbs", "active": true, "timeZone": "America/New_York"}, "created": "2025-08-20T22:18:56.488+0000", "updated": "2025-08-20T22:18:56.488+0000"}], "maxResults": 1, "total": 1, "startAt": 0}, "customfield_12311820": "0|z1xcew:", "customfield_12314139": null}}